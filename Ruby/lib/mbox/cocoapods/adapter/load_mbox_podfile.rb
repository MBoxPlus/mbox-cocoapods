
require 'digest'
require "mbox/mbox/config/config.rb"
require "mbox/mbox/config/repo.rb"

module Pod
  class Config
    alias_method :ori_podfile, :podfile
    def podfile
      # ori_podfile
      # return @podfile if @podfile
      @podfile ||= Podfile.from_mbox
    end
    def installation_root
        @installation_root ||= Pathname.new(::MBox::Config.instance.project_root)
    end
    def podfile_path
        @podfile_path ||= ::MBox::Config::Repo.podfile_path
    end
  end

  class Podfile
    attr_accessor :sub_files

    alias_method :mbox_pod_project_0104, :project
    def project(path, build_configurations = {})
      if Pathname(path).relative?
        path = (Pathname(Dir.pwd) + path).relative_path_from(defined_in_file.dirname.realpath).to_s
      end
      mbox_pod_project_0104(path, build_configurations)
    end

    def self.from_mbox
      current_feature = ::MBox::Config.instance.current_feature
      current_containers = current_feature.current_cocoapods_containers
      if current_containers.blank?
          raise StandardError, "No activated CocoaPods container. Use `mbox container use [NAME]` to activate one."
      end
      UI.message "[MBox] Integrate containers: #{current_containers.map(&:name).to_sentence}"

      Podfile.new(MBox::Config::Repo.podfile_path) do
        @sub_files = {}
        all_contents = {}
        current_containers.each do |container|
          repo = current_feature.find_repo(container.repo_name)
          next if repo.blank?

          path = repo.podfile_path_by_name(container.name)
          if path
            contents = File.open(path, 'r:utf-8', &:read)
            # Work around for Rubinius incomplete encoding in 1.9 mode
            if contents.respond_to?(:encoding) && contents.encoding.name != 'UTF-8'
              contents.encode!('UTF-8')
            end
            # contents = <<~EOF
            # abstract_target "#{repo.name}" do
            #     inherit! :none
            #     #{contents}
            # end
            # EOF
            @sub_files[repo.name] = path
          elsif repo.podspec_path
            # There is not the `target`, I don't known which target should be installed in.
            next
          else
            UI.warn "`#{repo.name}` has NOT a `Podfile` or a `*.xcodeproj`. Skip it."
            next
          end
          if contents.tr!('“”‘’‛', %(""'''))
            # Changes have been made
            CoreUI.warn "Smart quotes were detected and ignored in your #{path.basename}. " \
                'To avoid issues in the future, you should not use ' \
                'TextEdit for editing it. If you are not using TextEdit, ' \
                'you should turn off smart quotes in your editor of choice.'
          end

          all_contents[path] = <<-EOF


################################## #{repo.name} ##################################
Dir.chdir("#{path.dirname.relative_path_from(MBox::Config.instance.project_root)}") do
  #{
  if project_path = repo.project_path_by_name(container.name)
    %(project "#{project_path.relative_path_from(path.dirname)}")
  end
  }
  #{contents.gsub("\n", "\n    ")}
end
EOF
        end
        post_contents = ["workspace '#{MBox::Config::Repo.workspace_path}'"]
        contents = "\n#### Warning: This file is generated by MBox, you could NOT modify it. ####" + all_contents.values.join + post_contents.join

        podfile_path = MBox::Config::Repo.podfile_path
        FileUtils.chmod('u+w', podfile_path) if podfile_path.exist?
        File.write(podfile_path, contents)
        FileUtils.chmod('u-w', podfile_path) if podfile_path.exist?

        Dir.chdir(MBox::Config.instance.project_root) do
          all_contents.each do |path, c|
            contents << c
            eval(c, nil, path.to_s)
          end
          post_contents.each do |c|
            eval(c, nil, MBox::Config::Repo.podfile_path.to_s)
          end
        end
      end
    end

    class TargetDefinition

      # Resolve the relative path, inject `Dir.chdir` into the path.
      def resolve_relative_path(path)
        dirpath = podfile.defined_in_file.dirname.realpath
        return path if dirpath.to_s == Dir.pwd
        if Pathname(path).relative?
          (Pathname(Dir.pwd) + path).relative_path_from(dirpath).to_s
        else
          path
        end
      end

      alias_method :mbox_pod_initialize_0104, :initialize
      def initialize(name, parent, internal_hash = nil)
        mbox_pod_initialize_0104(name, parent, internal_hash)
        unless user_project_path.blank?
          podfile_dir = podfile.defined_in_file.dirname
          self.user_project_path = (podfile_dir + user_project_path).relative_path_from(Pathname.pwd)
        end
        @sandbox_dir = Pathname.pwd
      end

      attr_reader :sandbox_dir

      alias_method :mbox_pod_store_pod_0104, :store_pod
      def store_pod(name, *requirements)
        options = requirements.last
        unless options.is_a?(Hash)
          options = {}
          requirements << options
        end

        @cached_paths ||= {}
        pod_name = Specification.root_name(name)

        dev_podspec_path = MBox::Config.instance.development_pods[pod_name]

        path, type = @cached_paths[pod_name]
        if type.blank? || path.blank?
          if dev_podspec_path
            # The development pod should ignore the requirement.
            path = dev_podspec_path.dirname
            path = path.relative_path_from(podfile.defined_in_file.dirname) if podfile.defined_in_file
            @cached_paths[pod_name] = [path.to_s, :path]
          else
            # Update the relative path
            if path = options[:path]
              @cached_paths[pod_name] = [resolve_relative_path(path), :path]
            end
          end
        end

        path, type = @cached_paths[pod_name]
        if !type.blank? && !path.blank?
          options.delete(:path)
          options.delete(:podspec)
          options.delete(:source)
          options.delete(:git)
          options.delete(:commit)
          options.delete(:tag)
          options.delete(:branch)
          options[type] = path
        end

        if dev_podspec_path
          # Clean the version requirement.
          requirements = [options]
        end

        requirements.pop if requirements.last.blank?
        mbox_pod_store_pod_0104(name, *requirements)
      end

      alias_method :mbox_pod_store_podspec_0104, :store_podspec
      def store_podspec(options = nil)
        options = (options || {}).dup
        path = options[:path]
        if path.nil?
          # The Autoselect not work, instead, we scan the directory to get the podspec file.
          path = Dir["#{options[:name] || "*"}.{podspec,podspec.json}"].first
          if path.blank?
            raise StandardError, "Could not find the podspec in `#{Dir.pwd}`."
          end
          options.delete(:name)
        end
        options[:path] = resolve_relative_path(path)
        mbox_pod_store_podspec_0104(options)
      end

      alias_method :mbox_pod_inhibits_warnings_for_pod_0523?, :inhibits_warnings_for_pod?
      def inhibits_warnings_for_pod?(pod_name)
        if MBox::Config.instance.development_pods[pod_name]
          # disable inhibit_warnings for development pods
          false
        else
          mbox_pod_inhibits_warnings_for_pod_0523?(pod_name)
        end
      end
    end
  end

  # The verison file (in the local development repository) maybe different with the release version.
  # It will raise a conflict. We handle this case to ignore it.
  class Resolver
    alias_method :mbox_requirement_satisfied_by_0108?, :requirement_satisfied_by?
    def requirement_satisfied_by?(requirement, activated, spec)
      return true if mbox_requirement_satisfied_by_0108?(requirement, activated, spec)
      spec_path = MBox::Config.instance.development_pods[Specification.root_name(requirement.name)]
      if spec_path
        UI.warn "Local Pod `#{spec_path} (#{spec.version})` is in conflict with `#{requirement}`, MBox force use the local development pod."
        return true
      end
      false
    end

    alias_method :mbox_specifications_for_dependency_0108, :specifications_for_dependency
    def specifications_for_dependency(dependency, additional_requirements = [])
      if (podspec_path = MBox::Config.instance.development_pods[Specification.root_name(dependency.name)]) && 
        (spec = Specification.from_file(podspec_path))
        spec = spec.subspec_by_name(dependency.name, false, true)
        return [spec] if spec
      end
      mbox_specifications_for_dependency_0108(dependency, additional_requirements)
    end
  end

  class Installer
    class Analyzer
      alias_method :mbox_pod_dependencies_to_fetch_0328, :dependencies_to_fetch
      def dependencies_to_fetch(podfile_state)
        @deps_to_fetch ||= begin
          deps_to_fetch = mbox_pod_dependencies_to_fetch_0328(podfile_state)
          MBox::Config.instance.development_pods.each do |name, podspec_path|
            deps_to_fetch.delete_if { |dep| dep.name == name }
            external_source = { :path => podspec_path.dirname.relative_path_from(config.installation_root).to_s }
            deps_to_fetch << Dependency.new(name, external_source)
          end
          deps_to_fetch
        end
      end
    end
  end
end
